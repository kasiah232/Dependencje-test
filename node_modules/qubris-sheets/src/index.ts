import * as xlsx from 'xlsx';
import { applyStyles, findCell, getCellStyles, getExcelColumnLabel } from './helper';
import { IQbrisSheetsOptions } from './types';

export class QbrisSheet {
  // props;
  private _absoluteMaximumColumns = 26 * 13; // til AZ
  private _absoluteMaximumRows = 2000;
  private _maxColumns = 26;
  private _maxRows = 200;
  private _containerSelector: string | null = null;
  private _container: HTMLElement | null = null;
  private _fxField: HTMLInputElement | null = null;
  private _sheetDataBuffer: Uint8Array | null = null;
  private workBook: xlsx.WorkBook | null = null;

  private footerButtonStyle: string = "_QbrisSheet_footer_button";
  private footerBarStyle: string = "_QbrisSheet_footer_bar";
  private tableWrapperStyle: string = "_QbrisSheet_table_wrapper";
  private tableStyle: string = "_QbrisSheet_table";
  private tableHeaderStyle: string = "_QbrisSheet_header";
  private cellStyle: string = "_QbrisSheet_cell";

  private renderFooter: boolean = true;

  private currentSheet: string | null = null;
  private _activeCell: HTMLElement | null = null;
  private _activeCellRange: string[] = [];
  private _highlightOverlay: HTMLElement | null = null;
  private renderOnlySheetRange: boolean = false;
  private _onLoading: (isLoading: boolean) => void = () => {};

  // handlers;
  private handleError: (error: Error) => void;

  // getters;
  private get sheetDataBuffer(): Uint8Array | null {
    return this._sheetDataBuffer;
  }

  public get container(): HTMLElement | null {
    return this._container;
  }

  public get containerSelector(): string | null {
    return this._containerSelector;
  }

  public get activeCell(): HTMLElement | null {
    return this._activeCell;
  }

  // setters;
  private set sheetDataBuffer(buffer: Uint8Array | null) {
    this._sheetDataBuffer = buffer;
    this.workBook = xlsx.read(this._sheetDataBuffer, { 
      type: 'array', 
      cellStyles: true, 
      cellDates: true, 
      cellFormula: true, 
      cellHTML: true, 
      cellText: true,
    });
    this.currentSheet = this.workBook.SheetNames[0];
  };

  public setErrorHandler(handler: (error: Error) => void) {
    this.handleError = handler;
  }

  public setContainer(containerSelector: string) {
    this._containerSelector = containerSelector;
    this._container = document.querySelector(containerSelector);
    if (this.container === null) {
      this.handleError(new Error(`Container not found: ${containerSelector}`));
      return;
    }
  }

  public set activeCell(cell: HTMLElement | null) {
    if (this._activeCell) {
      this._activeCell.classList.remove(`${this.cellStyle}_active`);
    }
    this._activeCell = cell;
    if (this._activeCell) {
      this._highlightOverlay?.remove();
      this._highlightOverlay = null;
      const activeCellCords = this._activeCell.getAttribute('qbris-cords');
      this._activeCellRange = [
        activeCellCords!, 
        activeCellCords!
      ];
      this.updateGroupHighlight();
    }
    if (this._fxField && this._activeCell) {
      const activeCellCords = this._activeCell.getAttribute('qbris-cords');
      const coords = activeCellCords?.split('|').map((v) => parseInt(v) - 1);
      if (!coords) {
        return;
      }
      const [row, col] = coords;

      const sheet = this.workBook?.Sheets[this.currentSheet!];
      const cellAddress = xlsx.utils.encode_cell({ c: col, r: row });
      const cellData = sheet![cellAddress] || {};
      this._fxField.value = 
        cellData.f !== undefined ? 
          `=${cellData.f}` :
            cellData.v !== undefined ? 
            cellData.v : '';

    }
  }

  constructor(options?: IQbrisSheetsOptions) {
    if (options?.handleError) {
      this.handleError = options?.handleError;
    } else {
      this.handleError = (error: Error) => {
        alert(error);
      }
    }
    if (options?.containerSelector) {
      this._containerSelector = options.containerSelector;
      this._container = document.querySelector(options.containerSelector);
      if (this.container === null) {
        this.handleError(new Error(`Container not found: ${options.containerSelector}`));
        return;
      }
    }
    if (options?.renderFooter !== undefined) {
      this.renderFooter = options.renderFooter !== undefined ? options.renderFooter : true;
    } else {
      this.renderFooter = true;
    }

    if (options?.maxColumns) {
      this._maxColumns = options.maxColumns > this._absoluteMaximumColumns ? this._absoluteMaximumColumns : options.maxColumns;
    }

    if (options?.maxRows) {
      this._maxRows = options.maxRows > this._absoluteMaximumRows ? this._absoluteMaximumRows : options.maxRows;
    }

    if (options?.styles) {
      if (options.styles.footerButton) {
        this.footerButtonStyle = options.styles.footerButton;
      }
      if (options.styles.footerBar) {
        this.footerBarStyle = options.styles.footerBar;
      }
      if (options.styles.tableWrapperStyle) {
        this.tableWrapperStyle = options.styles.tableWrapperStyle;
      }
      if (options.styles.tableStyle) {
        this.tableStyle = options.styles.tableStyle;
      }
      if (options.styles.cellStyle) {
        this.cellStyle = options.styles.cellStyle;
      }
      if (options.styles.tableHeaderStyle) {
        this.tableHeaderStyle = options.styles.tableHeaderStyle;
      }
    }

    if (options?.renderOnlySheetRange !== undefined) {
      this.renderOnlySheetRange = options.renderOnlySheetRange;
    }
    
    if (options?.onLoading) {
      this._onLoading = options.onLoading;
    }

    document.addEventListener('copy', this.handleCopy.bind(this));

  }

  private handleCopy(event: ClipboardEvent) {
    event.preventDefault();
    if (this._activeCellRange && this._activeCellRange.length === 2) {
      const [start, end] = this._activeCellRange;
      const [xa, ya] = start.split('|').map((v) => parseInt(v));
      const [xb, yb] = end.split('|').map((v) => parseInt(v));
      const xMin = Math.min(xa, xb);
      const xMax = Math.max(xa, xb);
      const yMin = Math.min(ya, yb);
      const yMax = Math.max(ya, yb);

      if (xMin && xMax && yMin && yMax) {
        let data = '';
        for (let rowIndex = xMin - 1; rowIndex < xMax; rowIndex++) {
          let row = '';
          for (let colIndex = yMin - 1; colIndex < yMax; colIndex++) {
            const cell = findCell(`${rowIndex + 1}|${colIndex + 1}`, this.container as HTMLElement);
            if (cell) {
              row += cell.innerText + '\t';
            }
          }
          data += row + '\n';
        }
        event.clipboardData?.setData('text/plain', data);
      }
    }
  }

  private handleDragStart(event: DragEvent) {
    const target = event.target as HTMLElement;
    this._activeCell = null;
    if (target.tagName === 'TD') {
      const cellCords = target.getAttribute('qbris-cords');
      if (cellCords) {
        event.dataTransfer?.setData('text/plain', cellCords);
        var img = new Image();
        img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
        event.dataTransfer?.setDragImage(img, 0, 0);
        this._activeCellRange = [cellCords];
        this.updateGroupHighlight();
      }
    }
  }

  private handleDragOver(event: DragEvent) {
    event.preventDefault();
    const target = event.target as HTMLElement;
    if (target.tagName === 'TD') {
      const cellCords = target.getAttribute('qbris-cords');
      if (cellCords) {
        this._activeCellRange[1] = cellCords;
        this.updateGroupHighlight();
      }
    }
  }

  private handleDragEnd(event: DragEvent) {
    event.preventDefault();
  }

  private updateGroupHighlight() {
    const [start, end] = [...this._activeCellRange];
    if (start && end) {
      const [xa, ya] = start.split('|').map((v) => parseInt(v));
      const [xb, yb] = end.split('|').map((v) => parseInt(v));
      const xMin = Math.min(xa, xb);
      const xMax = Math.max(xa, xb);
      const yMin = Math.min(ya, yb);
      const yMax = Math.max(ya, yb);

      if (xMin && xMax && yMin && yMax) {
        let exists = true;
        let highlightOverlay: HTMLElement | null = document.querySelector('._QbrisSheet_highlight_overlay');
        if (!highlightOverlay) {
          highlightOverlay = document.createElement('div');
          highlightOverlay.className = '_QbrisSheet_highlight_overlay';
          highlightOverlay.style.position = 'absolute';
          // highlightOverlay.style.zIndex = '999';
          exists = false;
          this._highlightOverlay = highlightOverlay;
        }

        const startCell = findCell(`${xMin}|${yMin}`, this.container as HTMLElement);
        const endCell = findCell(`${xMax}|${yMax}`, this.container as HTMLElement);

        if (!startCell || !endCell) {
          return;
        }

        const startCellRect = startCell.getBoundingClientRect();
        const endCellRect = endCell.getBoundingClientRect();
        const containerRect = this.container?.getBoundingClientRect();

        highlightOverlay.style.top = `${startCellRect.top - (containerRect?.top || 0)}px`;
        highlightOverlay.style.left = `${startCellRect.left - (containerRect?.left || 0)}px`;
        highlightOverlay.style.width = `${endCellRect.right - startCellRect.left - 4}px`;
        highlightOverlay.style.height = `${endCellRect.bottom - startCellRect.top - 4}px`;

        if (!exists) {
          this.container?.appendChild(highlightOverlay);
        }
      }
    } else if (this._highlightOverlay && this._activeCellRange.length === 0) {
      this._highlightOverlay.remove();
    }
  }

  private handleMouseDragSelection() {
    const table = this.container?.querySelector(`.${this.tableStyle}`);
    if (table) {
      (table as HTMLTableElement).addEventListener('dragstart', this.handleDragStart.bind(this));
      (table as HTMLTableElement).addEventListener('dragover', this.handleDragOver.bind(this));
      (table as HTMLTableElement).addEventListener('dragend', this.handleDragEnd.bind(this));
    }
  }

  private readFileObject(file: File): Promise<Uint8Array> {
    return new Promise<Uint8Array>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        if (!e.target || !e.target.result) {
          reject(new Error('Failed to read file'));
          return;
        }
        resolve(new Uint8Array(e.target.result as ArrayBuffer));
      };
      reader.onerror = () => {
        reject(new Error('Failed to read file'));
      };
      reader.readAsArrayBuffer(file);
    })
  }

  async loadLocalFile() {
    const input = document.createElement('input');
    input.style.display = 'none';
    input.type = 'file';
    input.accept = '.xlsx, .xls, .csv, .txt, .tsv, .ssv';
    document.body.appendChild(input);
    
    try {
      const file = await new Promise<File | undefined>((resolve) => {
        input.onchange = (e) => {
          this._onLoading(true);
          this.unload();
          const file = (e.target as HTMLInputElement)?.files?.[0];
          resolve(file);
        };
        input.click();
      });

      if (!file) {
        this.handleError(new Error('No file selected'));
        return;
      }

      const sheetData = await this.readFileObject(file);

      this.sheetDataBuffer = sheetData;
    } catch (error) {
      this.handleError((error as Error));
    } finally {
      input.remove();
      this._onLoading(false);
    }
  }

  async loadRemoteFile(url: string) {
    this._onLoading(true);
    try {
      const response = await fetch(url);
      if (!response.ok) {
        this.handleError(new Error(`Failed to fetch file: ${response.statusText}`));
        return;
      }
      this.unload();
      this.sheetDataBuffer = new Uint8Array(await response.arrayBuffer());
    } catch (error) {
      this.handleError((error as Error));
    } finally {
      this._onLoading(false);
    }
  }

  unload() {
    const wrapper = document.querySelector(`.${this.tableWrapperStyle}`);
    if (wrapper) {
      wrapper.remove();
    }
    const footer = document.querySelector(`.${this.footerBarStyle}_wrapper`);
    if (footer) {
      footer.remove();
    }
    const header = document.querySelector(`.${this.tableHeaderStyle}`);
    if (header) {
      header.remove();
    }

    this.workBook = null;

  }
  
  async jumpToSheet(sheetName: string) {
    if (this.workBook === null) {
      this.handleError(new Error('No workbook loaded'));
      return;
    }
    if (this.workBook.SheetNames.indexOf(sheetName) === -1) {
      this.handleError(new Error(`Sheet not found: ${sheetName}`));
      return;
    }

    this._activeCellRange = [];
    this.updateGroupHighlight();

    if (this.renderFooter) {
      document.querySelectorAll('#footer button')
        .forEach(btn => btn.classList.remove(`${this.footerButtonStyle}_active`));
      const btn: HTMLElement | undefined = Array.from(document.querySelectorAll(`#footer button`)).find(
        (btn: Element) => (btn as HTMLElement).innerText === sheetName
      ) as HTMLElement | undefined;
      btn?.classList.add(`${this.footerButtonStyle}_active`);
    }

    this.currentSheet = sheetName;

    if (this.renderOnlySheetRange && this.currentSheet) {
      const range = xlsx.utils.decode_range(this.workBook.Sheets[this.currentSheet]['!ref']!);
      this._maxColumns = range.e.c > this._absoluteMaximumColumns ? this._absoluteMaximumColumns : range.e.c;
      this._maxRows = range.e.r > this._absoluteMaximumRows ? this._absoluteMaximumRows : range.e.r;

      const wrapper = document.querySelector(`.${this.tableWrapperStyle}`);
      if (wrapper) {
        wrapper.remove();
      }
      await this.renderTable();
      this.handleMouseDragSelection();
    }

    await this.renderTableContnet();
  }

  async render() {
    await this.renderTableHeader();
    await this.renderTable();
    this.handleMouseDragSelection();
    if (this.renderFooter) {
      await this._renderFooter();
    }
  }

  private async renderTableContnet() {
    if (this.workBook === null) {
      this.handleError(new Error('No workbook loaded'));
      return;
    }
    if (!this.currentSheet) {
      this.handleError(new Error('No sheet selected'));
      return;
    }
    const sheet = this.workBook.Sheets[this.currentSheet];
    for (let rowIndex = 0; rowIndex < this._maxRows; rowIndex++) {
      for (let colIndex = 0; colIndex < this._maxColumns; colIndex++) {
        const cellAddress = xlsx.utils.encode_cell({ c: colIndex, r: rowIndex });
        const cellData = sheet[cellAddress] || {};

        const coords = `${rowIndex + 1}|${colIndex + 1}`;
        const cell = findCell(coords, this.container as HTMLElement);
        if (!cell) {
          console.warn(`Cell not found: ${coords}`);
        } else {
          cell.innerText = cellData.w !== undefined ? cellData.w : cellData.v !== undefined ? cellData.v : '';
        }

        const styles = getCellStyles(cellData);
        applyStyles(cell, styles);
      }
    }
  }

  private renderTableHeader() {
    if (!this.container) {
      this.handleError(new Error('Container parent not found'));
      return;
    }
    if (!this.workBook) {
      this.handleError(new Error('No workbook loaded'));
      return;
    }
    if (!this.currentSheet) {
      this.handleError(new Error('No sheet selected'));
      return;
    }

    const tableHeader = document.createElement('div');
    tableHeader.className = this.tableHeaderStyle;

    const fx = document.createElement('span');
    fx.innerText = 'ƒ(x)';
    fx.style.width = '24px';
    fx.style.lineHeight = '24px';
    fx.style.textAlign = 'center';
    fx.style.padding = '4px 10px';
    tableHeader.appendChild(fx);

    const fxField = document.createElement('input');
    fxField.type = 'text';
    fxField.disabled = true;
    fxField.style.height = '20px';
    fxField.style.width = 'calc(100% - 24px)';
    fxField.style.padding = '2px 8px';
    fxField.style.margin = '2px 8px';
    fxField.style.fontSize = '14px';
    fxField.style.border = '1px solid lightgray';
    fxField.style.backgroundColor = 'white';
    tableHeader.appendChild(fxField);
    this._fxField = fxField;

    this.container.prepend(tableHeader);
  }

  private async renderTable() {
    if (!this.container) {
      this.handleError(new Error('Container parent not found'));
      return;
    }
    if (!this.workBook) {
      this.handleError(new Error('No workbook loaded'));
      return;
    }
    if (!this.currentSheet) {
      this.handleError(new Error('No sheet selected'));
      return;
    }

    const wrapper = document.createElement('div');

    wrapper.addEventListener('scroll', (e) => {
      this.updateGroupHighlight();
    });

    wrapper.className = this.tableWrapperStyle;
    const containerHeight = this.container.clientHeight;
    if (this.renderFooter) {
      wrapper.style.height = `${containerHeight - 37 - 33}px`;
    } else {
      wrapper.style.height = `${containerHeight - 33}px`;
    }
    const table = document.createElement('table');
    table.className = this.tableStyle;
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.appendChild(document.createElement('th'));
    for (let i = 0; i < this._maxColumns; i++) {
      const th = document.createElement('th');
      th.className = `${this.cellStyle}_th`;
      th.setAttribute('qbris-cords', `0|${i}`);
      th.innerText = getExcelColumnLabel(i);
      headerRow.appendChild(th);
    }
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    wrapper.appendChild(table);

    const tbody = document.createElement('tbody');

    for (let rowIndex = 0; rowIndex < this._maxRows; rowIndex++) {
      const row = document.createElement('tr');
      const rowHeader = document.createElement('th');
      rowHeader.className = `${this.cellStyle}_th`;
      rowHeader.setAttribute('qbris-cords', `${rowIndex + 1}|0`);
      rowHeader.innerText = `${rowIndex + 1}`;
      row.appendChild(rowHeader);

      for (let colIndex = 0; colIndex < this._maxColumns; colIndex++) {
        const td = document.createElement('td');
        td.className = `${this.cellStyle}_td`;
        td.draggable = true;
        td.setAttribute('qbris-cords', `${rowIndex + 1}|${colIndex + 1}`);
        td.onclick = (e) => {
          this.activeCell = e.target as HTMLElement;
        }
        row.appendChild(td);
      }
      tbody.appendChild(row);
    }
    table.appendChild(tbody);

    const header = this.container.querySelector(`.${this.tableHeaderStyle}`);
    if (header) {
      this.container.insertBefore(wrapper, header.nextSibling);
    } else {
      this.container.prepend(wrapper);
    }
  }

  private async _renderFooter() {
    if (!this.workBook) {
      this.handleError(new Error('No workbook loaded'));
      return;
    }

    const sheetNames = this.workBook.SheetNames;
    if (!this.container) {
      this.handleError(new Error('Container parent not found'));
      return;
    }
    const footerWrapper = document.createElement('div');
    footerWrapper.className = `${this.footerBarStyle}_wrapper`;

    const footer = document.createElement('div');
    footer.className = this.footerBarStyle;
    footer.id = 'footer';
    footerWrapper.appendChild(footer);

    const separator = document.createElement('div');
    separator.style.height = '28px';
    separator.style.width = '1px';
    separator.style.backgroundColor = 'lightgray';
    separator.style.margin = '4px 8px';
    separator.style.boxShadow = '1px 1px 1px rgba(0, 0, 0, 0.2)';

    footerWrapper.appendChild(separator);
    
    const prevButton = document.createElement('button');
    prevButton.className = this.footerButtonStyle;
    prevButton.innerText = "➤";
    prevButton.style.transform = 'rotate(180deg)';
    prevButton.addEventListener('click', async () => {
      footer.scrollLeft -= 200;
    });

    const nextButton = document.createElement('button');
    nextButton.className = this.footerButtonStyle;
    nextButton.innerText = "➤";
    nextButton.addEventListener('click', async () => {
      footer.scrollLeft += 200;
    });

    footerWrapper.appendChild(prevButton);
    footerWrapper.appendChild(nextButton);

    this.container.appendChild(footerWrapper);

    footer.innerHTML = '';
    sheetNames.forEach((sheetName, index) => {
      const button = document.createElement('button');
      button.className = this.footerButtonStyle;
      button.addEventListener('click', async () => {
        await this.jumpToSheet(sheetName);
      });
      const span = document.createElement('span');
      span.innerText = sheetName;
      button.appendChild(span);
      footer.appendChild(button);
      if (index === 0) {
        this.jumpToSheet(sheetName);
      }
    });
  }
}

export default QbrisSheet;