"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeOptions = exports.newts = exports.defaultOptions = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const null_feedback_1 = require("./ux/null-feedback");
const os_1 = require("os");
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const yafs_1 = require("yafs");
const io_1 = require("./io");
const yafs_2 = require("yafs");
const licenses_1 = require("./ux/licenses");
const git_1 = require("./git");
const utils_1 = require("./utils");
const npm_1 = require("./npm");
validateNodeVersionAtLeast(10, 12);
exports.defaultOptions = {
    includeLinter: true,
    includeNodeTypes: true,
    includeFaker: true,
    includeJest: true,
    includeExpectEvenMoreJest: true,
    includeZarro: true,
    setupTestScript: true,
    setupBuildScript: true,
    setupReleaseScripts: true,
    initializeGit: true,
    testEnvironment: "node",
    // TODO: add cli options for these
    setupGitHubRepo: false,
    setupGitHubRepoPrivate: false,
    installPackagesOneAtATime: false,
    verifyNameAvailable: true
};
const licenseReplacements = {
    "author": [/<copyright holder>/i, /<copyright holders>/i],
    "year": [/<year>/i, /\[year]/i]
};
async function newts(rawOptions) {
    await (0, npm_1.checkNpm)();
    const opts = await sanitizeOptions(rawOptions);
    const run = opts.feedback.run.bind(opts.feedback);
    await createModuleFolder(opts);
    await (0, utils_1.runInFolder)(opts.fullPath, async () => {
        await initGit(opts);
        const isNew = await run(`initialise package ${opts.name}`, () => initPackage(opts));
        await run(`set up package.json defaults`, () => setupPackageJsonDefaults(opts, isNew));
        if (!skipLicense(opts.license)) {
            await run(`install license: ${opts.license}`, () => installLicense(opts));
        }
        else {
            await alterPackageJson(pkg => {
                return { ...pkg, license: "UNLICENSED" };
            });
        }
        await run(`install README.md`, () => createReadme(opts));
        await setAuthorInfo(opts);
        await installDevPackages(opts);
        await installReleasePackages(opts);
        // some npm scripts are required for config generation: particularly the build script (tsc)
        await run(`add npm scripts`, () => addNpmScripts(opts));
        await run(`seed project files`, () => seedProjectFiles(opts));
        await run(`generate configurations`, () => generateConfigurations(opts));
        await run(`perform initial build`, () => (0, npm_1.runNpm)("run", "build"));
        printComplete(opts);
    });
}
exports.newts = newts;
async function setAuthorInfo(options) {
    const authorInfo = {};
    if (options.authorName) {
        authorInfo.name = options.authorName;
    }
    if (options.authorEmail) {
        authorInfo.email = options.authorEmail;
    }
    const keys = Object.keys(authorInfo);
    if (keys.length === 0) {
        return;
    }
    await options.feedback.run(`set author information`, () => alterPackageJson(pkg => {
        const result = { ...pkg };
        if (typeof result.author === "string") {
            result.author = {};
        }
        result.author = result.author || {};
        keys.forEach(k => result.author[k] = authorInfo[k]);
        return result;
    }));
}
function printComplete(options) {
    options.feedback.log(`\n--- Congratulations! ---`);
    options.feedback.log(`${options.name} bootstrapped at ${options.fullPath}`);
    if (options.license) {
        options.feedback.warn(ansi_colors_1.default.yellow(`Please check ${path_1.default.join(options.fullPath, "LICENSE")} for any text you may need to replace, eg author information`));
    }
}
async function createReadme(options) {
    if (options.skipReadme) {
        return;
    }
    await (0, yafs_2.writeTextFile)("README.md", `${options.name}\n---\n${options.description}`);
}
function skipLicense(license) {
    return !license || [
        "none",
        "unlicensed"
    ].indexOf(license.toLowerCase()) > -1;
}
async function installLicense(options) {
    if (!options.license) {
        return;
    }
    const { license, authorName, authorEmail } = options;
    await copyBundledFile("LICENSE", `licenses/${license}`);
    if (authorName || authorEmail) {
        let licenseText = await (0, yafs_2.readTextFile)("LICENSE");
        if (authorName) {
            licenseReplacements.author.forEach(re => {
                licenseText = licenseText.replace(re, authorName);
            });
            const thisYear = (new Date()).getFullYear().toString();
            licenseReplacements.year.forEach(re => {
                licenseText = licenseText.replace(re, thisYear);
            });
        }
        await (0, yafs_2.writeTextFile)("LICENSE", licenseText);
    }
    await alterPackageJson(pkg => {
        return { ...pkg, license };
    });
}
async function seedProjectFiles(options) {
    await generateSrcMainFile(options);
    await generateModuleIndexFile(options);
    await generateModuleIndexTypingsFile(options);
    await generateCliEntryPoint(options);
    await generateTestIndexSpecFile(options);
    await generateTestSetupFile(options);
}
const newline = (0, os_1.platform)() === "win32"
    ? "\r\n"
    : "\n";
async function generateTestSetupFile(options) {
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "tests", "setup.ts"), "// include any test setup here");
}
async function generateTestIndexSpecFile(options) {
    if (!options.includeJest) {
        return;
    }
    const headers = [];
    if (options.includeExpectEvenMoreJest) {
        headers.push(`import "expect-even-more-jest";`);
    }
    if (options.includeFaker) {
        headers.push(`import { faker } from "@faker-js/faker";`);
    }
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "tests", "index.spec.ts"), `${headers.join(newline)}
describe(\`${options.name}\`, () => {
    it(\`should pass the example test\`, async () => {
        // Arrange
        // Act
        await expect(Promise.resolve(1))
            .resolves.toBeGreaterThan(0);
        // Assert
    });
});
`);
}
async function generateCliEntryPoint(options) {
    if (!options.isCommandline) {
        return;
    }
    const yargsImport = options.includeYargs
        ? `import yargs = require("yargs");\n`
        : "";
    const gatherOptions = options.includeYargs
        ? `
export interface CliOptions {
    someFlag: boolean;
    someOptionalString?: string;
}
function gatherOptions(): CliOptions | Promise<CliOptions> {
    return yargs
            .usage(\`usage: $0 [options]\nnegate any boolean option by prepending --no-\`)
            .option("someFlag", {
                type: "boolean",
                default: false
            }).option("someOptionalString", {
                type: "string",
                demandOption: false
            }).argv;
}`.trim()
        : ``;
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "src", `${options.name}-cli.ts`), `#!/usr/bin/env node
import { example } from "./index";
${yargsImport}
${gatherOptions}

(async function main() {
    const args = yargs.argv;
    example();
})();`);
}
async function generateSrcMainFile(options) {
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "src", `${options.name}.ts`), `// ${options.name} module main file
export function example() {
  console.log("hello, world");
}
`);
    await addBinScript(options);
}
async function generateModuleIndexFile(options) {
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "index.js"), `module.exports = require("./dist");`);
}
async function generateModuleIndexTypingsFile(options) {
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "index.d.ts"), `export * from "./dist";`);
}
async function addBinScript(options) {
    if (!options.isCommandline) {
        return;
    }
    await alterPackageJson(pkg => {
        const result = { ...pkg };
        result.bin = result.bin || {};
        result.bin[options.name] = `./dist/${options.name}-cli.js`;
        return result;
    });
}
async function alterPackageJson(transformer) {
    const pkg = await (0, io_1.readPackageJson)(), transformed = transformer(pkg);
    await (0, io_1.writePackageJson)(transformed);
}
async function generateConfigurations(options) {
    await generateTsLintConfig(options);
    await generateTsConfig(options);
    await generateJestConfig(options);
}
function determineBaseFolderFrom(name) {
    if (name.indexOf("/") === -1) {
        // simple case: continue
        return name;
    }
    if (name.startsWith("@")) {
        const parts = name.split("/");
        return parts.length > 1
            // possibly namespaced: just use the last part of the full name
            ? parts[parts.length - 1]
            // eh, @ is a valid fs name-char
            : name;
    }
    else {
        // gabba-gabba-hey! make names safe again
        return name.replace(/\//g, "__");
    }
}
async function sanitizeOptions(options) {
    var _a;
    if (!options) {
        throw new Error("No options provided");
    }
    if (!options.name) {
        throw new Error("No project name provided");
    }
    if (!options.feedback) {
        options.feedback = new null_feedback_1.NullFeedback();
    }
    const result = { ...exports.defaultOptions, ...options };
    if (!result.where) {
        result.where = determineBaseFolderFrom(result.name);
        result.fullPath = path_1.default.resolve(path_1.default.join(process.cwd(), result.where));
    }
    else {
        const baseName = path_1.default.basename(result.where);
        if (baseName === result.name) {
            result.fullPath = path_1.default.resolve(result.where);
        }
        else {
            result.fullPath = path_1.default.join(path_1.default.resolve(result.where), determineBaseFolderFrom(result.name));
        }
    }
    if (result.license) {
        const allLicenses = await (0, licenses_1.listLicenses)(), selected = (_a = result.license) !== null && _a !== void 0 ? _a : "", match = allLicenses.find(l => l.toLowerCase() === selected.toLowerCase());
        if (!match) {
            throw new Error(`license '${selected}' is unknown`);
        }
        result.license = match;
    }
    if (result.isCommandline &&
        result.addStartScript === undefined) {
        // default to add a start script
        result.addStartScript = true;
    }
    return result;
}
exports.sanitizeOptions = sanitizeOptions;
async function initGit(options) {
    if (!options.initializeGit) {
        return;
    }
    await options.feedback.run(`initialise git at ${options.fullPath}`, async () => {
        await (0, git_1.init)(options.fullPath);
        await setupGitIgnore();
    });
    if (options.setupGitHubRepo) {
        // TODO
        // 1. find or download gh
        // 2. test if repo already exists with module name
        // 3. if not: gh repo create (may need to handle gh interactive mode)
        console.error("github setup not yet implemented");
    }
}
async function setupGitIgnore() {
    await copyBundledFile(".gitignore", "_gitignore");
}
async function copyBundledFile(withName, fromName) {
    const pkgDir = await findMyPackageDir(), mine = path_1.default.join(pkgDir, fromName !== null && fromName !== void 0 ? fromName : withName);
    await cp(mine, withName);
}
async function cp(from, to) {
    return new Promise((_resolve, _reject) => {
        let completed = false;
        const outStream = (0, fs_1.createWriteStream)(to, { flags: "w" }), isComplete = () => {
            if (completed) {
                return true;
            }
            completed = true;
            return false;
        }, resolve = () => {
            if (isComplete()) {
                return;
            }
            outStream.end(() => _resolve());
        }, reject = (e) => {
            if (isComplete()) {
                return;
            }
            outStream.end(() => _reject(e));
        };
        (0, fs_1.createReadStream)(from)
            .on("end", resolve)
            .on("error", reject)
            .pipe(outStream);
    });
}
async function findMyPackageDir() {
    let current = __dirname;
    while (true) {
        const test = path_1.default.join(current, "package.json");
        if (await (0, yafs_1.fileExists)(test)) {
            return current;
        }
        const next = path_1.default.dirname(current);
        if (next === current) {
            throw new Error("can't find my own package dir");
        }
        current = next;
    }
}
function createModuleFolder(options) {
    return (0, yafs_1.mkdir)(options.fullPath);
}
const defaultTsLintOptions = {
    "defaultSeverity": "error",
    "extends": [
        "tslint:recommended"
    ],
    "jsRules": {},
    "rules": {
        "quotemark": [true, "double"],
        "one-variable-per-declaration": false,
        "ordered-imports": false,
        "no-console": false
    },
    "rulesDirectory": []
};
async function generateTsLintConfig(options) {
    if (!options.includeLinter) {
        return;
    }
    await (0, yafs_2.writeTextFile)(path_1.default.join(options.fullPath, "tslint.json"), JSON.stringify(defaultTsLintOptions, null, 2));
}
async function setupPackageJsonDefaults(options, isNew) {
    await alterPackageJson(pkg => {
        const result = { ...pkg };
        if (isNew) {
            result.version = "0.0.1";
        }
        result.main = "index.js";
        result.files = [
            "dist/**/*",
            "index.js",
            "index.d.ts"
        ];
        return result;
    });
}
async function initPackage(opts) {
    const alreadyExists = await (0, yafs_1.fileExists)("package.json");
    if (alreadyExists) {
        return !alreadyExists;
    }
    await (0, npm_1.runNpm)("init", "-y");
    // enforce that the correct name was used
    await alterPackageJson(pkg => {
        var _a;
        return {
            ...pkg,
            name: opts.name,
            description: (_a = opts.description) !== null && _a !== void 0 ? _a : ""
        };
    });
    return true;
}
const devPackageMap = {
    "yafs": () => true,
    typescript: () => true,
    tslint: o => !!o.includeLinter,
    "@types/node": o => !!o.includeNodeTypes,
    "@faker-js/faker": o => !!o.includeFaker,
    jest: o => !!o.includeJest,
    "@types/jest": o => !!o.includeJest,
    "ts-jest": o => !!o.includeJest,
    "ts-node": o => !!o.isCommandline && !!o.addStartScript,
    "expect-even-more-jest": o => !!o.includeExpectEvenMoreJest,
    zarro: o => !!o.includeZarro,
    "npm-run-all": () => true,
    "@types/yargs": o => !!o.isCommandline && !!o.includeYargs,
    "cross-env": () => true,
    "rimraf": o => !!o.setupTestScript
};
const releasePackageMap = {
    "yargs": o => !!o.isCommandline && !!o.includeYargs
};
async function installPackages(isDev, options, map) {
    const packages = Object.keys(map)
        .map(k => {
        return {
            name: k,
            install: map[k](options)
        };
    })
        .filter(o => o.install)
        .map(o => o.name)
        .sort();
    if (packages.length === 0) {
        return;
    }
    const s = packages.length === 1 ? "" : "s", label = isDev ? "dev" : "release", save = isDev ? "--save-dev" : "--save", args = ["install", save, "--no-progress"], timeWarning = packages.length > 3
        ? "(may take a minute)"
        : "", operationLabel = `install ${packages.length} ${label} package${s} ${timeWarning}`;
    if (options.installPackagesOneAtATime) {
        options.feedback.log(operationLabel);
        for (const pkg of packages) {
            await options.feedback.run(`  ${pkg}`, () => (0, npm_1.runNpm)(...args.concat([pkg])));
        }
    }
    else {
        await options.feedback.run(operationLabel, () => (0, npm_1.runNpm)(...args.concat(packages)));
    }
}
async function installDevPackages(options) {
    return installPackages(true, options, devPackageMap);
}
async function installReleasePackages(options) {
    return installPackages(false, options, releasePackageMap);
}
async function generateTsConfig(sanitizedOptions) {
    if (sanitizedOptions.skipTsConfig) {
        return;
    }
    const fname = "tsconfig.json";
    if (await (0, yafs_1.fileExists)(fname)) {
        await fs_1.promises.rename(fname, `${fname}.bak`);
    }
    await (0, npm_1.runNpm)("run", "build", "--", "--init");
    if (!(await (0, yafs_1.fileExists)(fname))) {
        throw new Error(`tsc --init didn't produce a ${fname}?`);
    }
    const lines = await (0, io_1.readLines)(fname);
    const updated = lines.map(setTarget)
        .map(uncommentDeclaration)
        .map(setDeclaration)
        .map(uncommentOutDir)
        .map(setOutDirToDist);
    const newLines = [
        `"exclude": [`,
        `  "tests",`,
        `  "dist"`,
        `]`
    ];
    const withComma = addCommaToCompilerOptionsBlock(updated);
    const lastBraceLine = withComma.reduce((acc, cur, idx) => cur.indexOf("}") > -1 ? idx : acc, 0);
    withComma.splice(lastBraceLine, 0, ...newLines);
    await (0, io_1.writeLines)(fname, withComma);
}
function addCommaToCompilerOptionsBlock(updated) {
    let braceCount = 0;
    return updated.map(line => {
        const decommented = decomment(line);
        if (decommented.indexOf("{") > -1) {
            braceCount++;
            return line;
        }
        if (decommented.indexOf("}") > -1) {
            braceCount--;
            if (braceCount === 1) {
                return line + ",";
            }
        }
        return line;
    });
}
function decomment(line) {
    return line.replace(/\/\/.*/, "")
        .replace(/\/\*.*\*\//g, "");
}
function setOutDirToDist(line) {
    return setJsonProp(line, "outDir", "./dist");
}
function uncommentOutDir(line) {
    return uncommentLineIfIsForProperty(line, "outDir");
}
function uncommentDeclaration(line) {
    return uncommentLineIfIsForProperty(line, "declaration");
}
function uncommentLineIfIsForProperty(line, prop) {
    return line.match(new RegExp(`^\\s*//\\s"${prop}"`))
        ? line.replace(/\/\//, "")
        : line;
}
function setDeclaration(line) {
    return setJsonProp(line, "declaration", true);
}
function setTarget(line) {
    return setJsonProp(line, "target", "ES2018");
}
function setJsonProp(line, prop, value) {
    if (!line.match(new RegExp(`^\\s*"${prop}"`))) {
        return line;
    }
    return replaceNthMatch(line, /("[^"]+")/, 2, JSON.stringify(value));
}
async function generateJestConfig(options) {
    const cfg = "jest.config.js";
    await copyBundledFile(cfg);
    const currentConfig = await (0, yafs_2.readTextFile)(cfg), lines = currentConfig.split("\n"), newLines = lines.reduce((acc, cur) => {
        const match = cur.match(/(\s*)testEnvironment:/);
        if (!!match) {
            const prefix = match[1];
            acc.push(`${prefix}testEnvironment: "${options.testEnvironment}",`);
        }
        else {
            acc.push(cur);
        }
        return acc;
    }, []);
    await (0, io_1.writeLines)(cfg, newLines);
}
async function addBuildNpmScript() {
    await copyBundledFile("generate-index.js");
    await addScript("clean-dist", "rimraf dist");
    await addScript("generate-index", "node generate-index.js");
    await addScript("prebuild", "run-p clean-dist generate-index");
    await addScript("build", "tsc");
}
async function addScript(name, script) {
    await alterPackageJson(pkg => {
        const result = { ...pkg };
        result.scripts = result.scripts || {};
        result.scripts[name] = script;
        return result;
    });
}
async function addReleaseScript() {
    await addScript("prerelease", "run-s build lint test");
    await addScript("release", "cross-env VERSION_INCREMENT_STRATEGY=minor run-s \"zarro release-npm\"");
}
async function addBetaReleaseScript() {
    await addScript("prerelease-beta", "run-s build lint test");
    await addScript("release-beta", "cross-env BETA=1 VERSION_INCREMENT_STRATEGY=patch run-s \"zarro release-npm\"");
}
async function addTestNpmScript() {
    await addScript("test", "jest");
    await addScript("pretest", "rimraf .jest-cache");
}
function addLintNpmScript() {
    return addScript("lint", "tslint -p .");
}
function addZarroNpmScript() {
    return addScript("zarro", "zarro");
}
function addStartScript(options) {
    return addScript("start", `ts-node src/${options.name}-cli.ts`);
}
async function addNpmScripts(sanitizedOptions) {
    await addBuildNpmScript();
    await addLintNpmScript();
    await addTestNpmScript();
    if (sanitizedOptions.includeZarro) {
        await addZarroNpmScript();
        await addReleaseScript();
        await addBetaReleaseScript();
    }
    if (sanitizedOptions.isCommandline) {
        await addStartScript(sanitizedOptions);
    }
}
function validateNodeVersionAtLeast(requireMajor, requireMinor) {
    const [major, minor] = process.version.replace(/^v/, "")
        .split(".")
        .map(s => parseInt(s, 10))
        .map(i => isNaN(i) ? 0 : i);
    if (major < requireMajor) {
        if (minor < requireMinor) {
            throw new Error(`this library requires at least node 10.12 as it makes use of fs.mkdir with recursive option`);
        }
    }
}
// borrowed from https://stackoverflow.com/a/7958627/1697008
function replaceNthMatch(original, pattern, n, replace) {
    let parts, tempParts;
    if (pattern.constructor === RegExp) {
        // If there's no match, bail
        if (original.search(pattern) === -1) {
            return original;
        }
        // Every other item should be a matched capture group;
        // between will be non-matching portions of the substring
        parts = original.split(pattern);
        // If there was a capture group, index 1 will be
        // an item that matches the RegExp
        if (parts[1].search(pattern) !== 0) {
            throw { name: "ArgumentError", message: "RegExp must have a capture group" };
        }
    }
    else if (pattern.constructor === String) {
        parts = original.split(pattern);
        // Need every other item to be the matched string
        tempParts = [];
        for (let i = 0; i < parts.length; i++) {
            tempParts.push(parts[i]);
            // Insert between, but don't tack one onto the end
            if (i < parts.length - 1) {
                tempParts.push(pattern);
            }
        }
        parts = tempParts;
    }
    else {
        throw { name: "ArgumentError", message: "Must provide either a RegExp or String" };
    }
    // Parens are unnecessary, but explicit. :)
    const indexOfNthMatch = (n * 2) - 1;
    if (parts[indexOfNthMatch] === undefined) {
        // There IS no Nth match
        return original;
    }
    // Update our parts array with the new value
    parts[indexOfNthMatch] = typeof (replace) === "function"
        ? replace(parts[indexOfNthMatch].toString())
        : replace;
    // Put it back together and return
    return parts.join("");
}
