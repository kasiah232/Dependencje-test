#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldRunInteractive = exports.convertCliOptionsToBootstrapOptions = void 0;
const newts_1 = require("./newts");
const console_feedback_1 = require("./ux/console-feedback");
const name_is_available_at_npm_js_1 = require("./ux/interactive/validators/name-is-available-at-npm-js");
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const gather_args_1 = require("./ux/gather-args");
const ask_1 = require("./ux/ask");
const cli_options_1 = require("./ux/cli-options");
const licenses_1 = require("./ux/licenses");
const git_1 = require("./git");
const run_interactive_1 = require("./ux/interactive/run-interactive");
function isEmpty(s) {
    return (s || "").trim() === "";
}
async function printLicensesIfRequired(argv, feedback) {
    if (!argv["list-licenses"]) {
        return;
    }
    const licenses = await (0, licenses_1.listLicenses)();
    licenses.forEach(feedback.log.bind(feedback));
    process.exit(0);
}
async function printLicenseIfRequired(argv, feedback) {
    if (argv["show-license"] === undefined) {
        return;
    }
    try {
        const id = argv["show-license"], licenseText = await (0, licenses_1.readLicense)(id);
        feedback.log(licenseText);
        feedback.log(`\nfor more information, see: https://opensource.org/licenses/${id}`);
        process.exit(0);
    }
    catch (err) {
        const e = err;
        if ((e.message || "").startsWith("unknown license:")) {
            feedback.error(e.message);
            process.exit(1);
        }
        throw e;
    }
}
async function ensureName(argv) {
    if (!(argv.name || "").trim()) {
        argv.name = await (0, ask_1.ask)("Please give me a name for this module", s => !isEmpty(s));
    }
}
async function ensureOutput(argv, feedback) {
    if (!(argv.output || "").trim()) {
        argv.output = await (0, ask_1.ask)("Please specify an output folder for this module", async (s) => {
            if (isEmpty(s)) {
                return false;
            }
            if (await (0, git_1.isPartOfGitRepo)(s)) {
                feedback.warn("Please select a folder which is not already part of a git repository");
                return false;
            }
            return true;
        });
    }
}
function convertCliOptionsToBootstrapOptions(argv, feedback) {
    return {
        skipTsConfig: false,
        includeZarro: argv["install-zarro"],
        includeLinter: argv["install-linter"],
        includeExpectEvenMoreJest: argv["install-matchers"],
        includeFaker: argv["install-faker"],
        includeJest: argv["install-jest"],
        initializeGit: argv["init-git"],
        name: argv.name || "",
        description: argv.description,
        where: argv.output,
        isCommandline: argv.cli,
        includeYargs: argv["install-yargs"],
        addStartScript: argv["start-script"],
        license: argv.license,
        skipReadme: !argv["init-readme"],
        authorEmail: argv["author-email"],
        authorName: argv["author-name"],
        feedback,
        includeNodeTypes: argv["install-node-types"],
        setupBuildScript: argv["build-script"],
        setupReleaseScripts: argv["release-scripts"],
        setupTestScript: argv["test-script"],
        verifyNameAvailable: argv["verify-name-available"]
    };
}
exports.convertCliOptionsToBootstrapOptions = convertCliOptionsToBootstrapOptions;
function shouldRunInteractive(argv) {
    return argv.interactive ||
        !(argv.name || "").trim() ||
        !(argv.output || "").trim();
}
exports.shouldRunInteractive = shouldRunInteractive;
(async () => {
    if (!!global.jasmine) {
        // running in a test due to an import
        return;
    }
    const feedback = new console_feedback_1.ConsoleFeedback(), defaultOptions = await (0, cli_options_1.generateDefaults)(), rawArgv = (0, gather_args_1.gatherArgs)(defaultOptions), interactive = shouldRunInteractive(rawArgv), shouldApplyDefaults = rawArgv.defaults;
    const argv = shouldApplyDefaults
        ? await (0, cli_options_1.applyDefaults)(rawArgv)
        : rawArgv;
    if (rawArgv["verify-name-available"] === undefined) {
        rawArgv["verify-name-available"] = defaultOptions["verify-name-available"];
    }
    await printLicensesIfRequired(argv, feedback);
    await printLicenseIfRequired(argv, feedback);
    if (argv.name && rawArgv["verify-name-available"]) {
        if (await (0, name_is_available_at_npm_js_1.nameIsAvailableAtNpmJs)(argv.name) !== true) {
            console.error(`${argv.name} is already reserved at npmjs.com! Please pick another name.`);
            argv.name = undefined;
        }
    }
    const consoleOptions = interactive
        ? await (0, run_interactive_1.runInteractive)(argv, defaultOptions)
        : argv;
    await ensureName(consoleOptions);
    await ensureOutput(consoleOptions, feedback);
    const opts = convertCliOptionsToBootstrapOptions(consoleOptions, feedback);
    try {
        const isValid = !argv["verify-name-available"] ||
            await (0, name_is_available_at_npm_js_1.nameIsAvailableAtNpmJs)(argv.name);
        if (!isValid) {
            feedback.warn(`package name ${argv.name} is already reserved at npmjs.com`);
            process.exit(1);
        }
        await (0, newts_1.newts)(opts);
        process.exit(0);
    }
    catch (err) {
        const e = err;
        if (typeof e.message === "string") {
            console.error(ansi_colors_1.default.red(e.message));
            console.error(e.stack);
        }
        else {
            console.error(e);
        }
        process.exit(1);
    }
})();
