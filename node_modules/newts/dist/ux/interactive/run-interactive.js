"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInteractive = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const name_is_available_at_npm_js_1 = require("./validators/name-is-available-at-npm-js");
const inquirer_1 = __importDefault(require("inquirer"));
const required_1 = require("./validators/required");
const run_validators_1 = require("./run-validators");
const is_valid_package_name_1 = require("./validators/is-valid-package-name");
const is_not_in_git_repo_1 = require("./validators/is-not-in-git-repo");
const none_or_valid_email_1 = require("./validators/none-or-valid-email");
const licenses_1 = require("../licenses");
const path_1 = __importDefault(require("path"));
const yafs_1 = require("yafs");
inquirer_1.default.registerPrompt("autocomplete", require("inquirer-autocomplete-prompt"));
async function folderIsNotEmpty(where) {
    try {
        const contents = await (0, yafs_1.ls)(where);
        return !!contents.length;
    }
    catch (e) {
        return false;
    }
}
async function runInteractive(currentOptions, defaultOptions, verifying) {
    const licenses = await (0, licenses_1.listLicenses)();
    licenses.push("none");
    const inquirerResult = await inquirer_1.default.prompt([
        prompt("name", undefined, required_1.required, is_valid_package_name_1.isValidPackageName, async (value) => {
            if (!currentOptions["verify-name-available"]) {
                return true;
            }
            const isAvailable = await (0, name_is_available_at_npm_js_1.nameIsAvailableAtNpmJs)(value);
            if (isAvailable &&
                defaultOptions.output === process.cwd() &&
                await folderIsNotEmpty(defaultOptions.output)) {
                defaultOptions.output = path_1.default.join(defaultOptions.output, value);
            }
            return isAvailable;
        }),
        prompt("description", undefined),
        prompt("output", undefined, is_not_in_git_repo_1.isNotInGitRepo),
        prompt("author-name", notRunningDefaults, required_1.required),
        prompt("author-email", notRunningDefaults, none_or_valid_email_1.noneOrValidEmail),
        {
            type: "autocomplete",
            name: "license",
            when: () => {
                return verifying ||
                    (!currentOptions.defaults && !currentOptions.license);
            },
            message: q("license"),
            source: async (_, input) => input === undefined
                ? [defaultOptions.license]
                : licenses.filter(l => l.match(new RegExp(input, "i")))
        },
        yesNo("cli"),
        yesNoWhen("install-yargs", a => !!a.cli),
        yesNo("install-jest"),
        listWhen("test-environment", ["node", "jsdom"], a => !!a["install-jest"]),
        yesNoWhen("test-script", a => !!a["install-jest"]),
        yesNoWhen("install-faker", a => !!a["install-jest"]),
        yesNoWhen("install-matchers", a => !!a["install-jest"]),
        yesNo("install-linter"),
        yesNo("init-git"),
        yesNo("init-readme"),
        yesNo("build-script"),
        yesNo("install-zarro"),
        yesNoWhen("release-scripts", a => !!a["install-zarro"]),
    ]);
    const result = {
        ...currentOptions,
        ...inquirerResult
    };
    setUndefinedIfIsNone(result, ...noneableOptions);
    const verifyResult = await verifyConfig(result);
    switch (verifyResult) {
        case "modify":
            return runInteractive(result, result, true);
        case "ok":
            return result;
        case "quit":
            process.exit(1);
    }
    function notRunningDefaults(a) {
        return !a.defaults;
    }
    function notSet(setting) {
        return a => currentOptions[setting] === undefined &&
            a[setting] === undefined;
    }
    function yesNo(name) {
        return {
            name,
            type: "confirm",
            default: defaultOptions[name],
            message: q(name),
            when: (a) => verifying ||
                (notRunningDefaults(a) &&
                    notSet(name)(a))
        };
    }
    function listWhen(name, choices, when) {
        return {
            name,
            message: q(name),
            type: "list",
            choices,
            when: async (a) => {
                return verifying || await when(a);
            }
        };
    }
    function yesNoWhen(name, when) {
        return {
            name,
            type: "confirm",
            default: defaultOptions[name],
            message: q(name),
            when: async (a) => {
                if (verifying) {
                    return true;
                }
                return notRunningDefaults(a) &&
                    await notSet(name)(a) &&
                    await when(a);
            }
        };
    }
    function prompt(name, when, ...validators) {
        return {
            name,
            when: async (values) => {
                if (verifying) {
                    return true;
                }
                if (!when) {
                    when = () => true;
                }
                return await when(values) &&
                    notSet(name)(values);
            },
            message: q(name),
            default: () => defaultOptions[name],
            validate: async (value) => {
                return await (0, run_validators_1.runValidators)(value, ...validators);
            }
        };
    }
}
exports.runInteractive = runInteractive;
function setUndefinedIfIsNone(opts, ...keys) {
    keys.forEach(k => {
        if (opts[k] === "none") {
            opts[k] = undefined;
        }
    });
}
function q(setting) {
    const hint = noneableOptions.indexOf(setting) > -1
        ? " (enter 'none' to skip)"
        : "";
    return !!optionLabels[setting]
        ? `${optionLabels[setting]}${hint} ?`
        : `[[ ${setting} ]] ??`;
}
async function verifyConfig(config) {
    const lines = optionOrder.map(o => {
        const label = verifyLabels[o] || optionLabels[o];
        if (stringOptions.indexOf(o) > -1) {
            return `${label}: ${ansi_colors_1.default.yellow(config[o])}`;
        }
        else {
            const marker = config[o]
                ? ansi_colors_1.default.green("yes")
                : ansi_colors_1.default.red("no");
            return `${label}: ${marker}`;
        }
    });
    lines.forEach(line => console.log(line));
    const ans = await inquirer_1.default.prompt([{
            name: "value",
            message: "Proceed with the above configuration?",
            type: "list",
            choices: [
                "ok",
                "modify",
                "quit"
            ]
        }]);
    return ans.value;
}
const optionOrder = [
    "name",
    "description",
    "output",
    "author-name",
    "author-email",
    "license",
    "cli",
    "install-yargs",
    "install-jest",
    "test-environment",
    "test-script",
    "install-faker",
    "install-matchers",
    "install-linter",
    "build-script",
    "install-zarro",
    "release-scripts"
];
const stringOptions = [
    "name",
    "output",
    "author-name",
    "author-email",
    "license",
    "test-environment"
];
const noneableOptions = [
    "author-name",
    "author-email",
    "license"
];
const optionLabels = {
    name: "project name",
    description: "project description (optional)",
    output: "create project at",
    "author-name": "author name",
    "author-email": "author email",
    license: "project license",
    cli: "command-line app",
    "install-yargs": "install yargs",
    "init-git": "initialize git",
    "init-readme": "initialize README.md",
    "install-jest": "test with jest",
    "install-faker": "install @faker-js/faker",
    "install-matchers": "install extra jest matchers",
    "install-linter": "install linter",
    "install-zarro": "install zarro build scaffolding",
    "build-script": "setup build script",
    "test-script": "setup test script",
    "release-scripts": "setup release scripts",
    "test-environment": "test environment (select jsdom for browser-like testing)"
};
const verifyLabels = {
    "test-environment": "test environment"
};
