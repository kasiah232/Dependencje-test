"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleFeedback = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const ok = ansi_colors_1.default.green(`[  OK  ]`), fail = ansi_colors_1.default.red(`[ FAIL ]`), spinChars = ["|", "/", "-", "\\"];
function makeSpaces(howMany) {
    const spaces = [];
    for (let i = 0; i < howMany; i++) {
        spaces.push(" ");
    }
    return spaces.join("");
}
class ConsoleFeedback {
    constructor() {
        this.spinChar = spinChars[0];
        this._started = 0;
    }
    async run(label, action) {
        let timeout;
        try {
            return await this.time(async () => {
                timeout = this.wait(label);
                const result = await action();
                this.stopWait(timeout);
                this.rewrite(label, ok);
                return result;
            });
        }
        catch (e) {
            if (timeout) {
                this.stopWait(timeout);
            }
            this.rewrite(label, fail);
            throw e;
        }
        finally {
            process.stdout.write("\n");
        }
    }
    startTimer() {
        if (!process.env.TIME_OPERATIONS) {
            return;
        }
        this._started = Date.now();
    }
    reportTime() {
        if (!process.env.TIME_OPERATIONS) {
            return;
        }
        const taken = Date.now() - this._started;
        process.stdout.write(` (${(taken / 1000).toFixed(2)}s)`);
        this._started = 0;
    }
    async time(fn) {
        this.startTimer();
        const result = await fn();
        this.reportTime();
        return result;
    }
    wait(label) {
        this.spinChar = spinChars[0];
        return setInterval(() => this.spin(label), 500);
    }
    spin(label) {
        this.rewrite(label, `${this.nextSpinChar()}`, 2);
    }
    stopWait(timeout) {
        clearInterval(timeout);
    }
    nextSpinChar() {
        const idx = spinChars.indexOf(this.spinChar) + 1;
        this.spinChar = idx >= spinChars.length
            ? spinChars[0]
            : spinChars[idx];
        return this.spinChar;
    }
    rewrite(pre, post, padSize, cols) {
        cols = cols !== null && cols !== void 0 ? cols : 80;
        padSize = padSize !== null && padSize !== void 0 ? padSize : cols - pre.length - post.length;
        const padding = makeSpaces(padSize), clear = makeSpaces(cols);
        const finalLine = `\r${clear}\r${pre}${padding}${post}`;
        process.stdout.write(finalLine);
    }
    log(text) {
        console.log(text);
    }
    warn(text) {
        console.warn(text);
    }
    error(text) {
        console.error(ansi_colors_1.default.red(text));
    }
}
exports.ConsoleFeedback = ConsoleFeedback;
