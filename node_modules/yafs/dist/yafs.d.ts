/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { WriteFileOptions, Stats } from "./fs";
interface ReadFileOptions {
    encoding: string | null | BufferEncoding;
    flags?: string;
}
/**
 * Reads the file at the provided location
 * @param at
 * @param opts
 */
export declare function readFile(at: string, opts?: ReadFileOptions): Promise<Buffer>;
/**
 *
 * Reads the text file at the given location with the provided contents
 * - will create any required supporting folders
 * @param at
 */
export declare function readTextFile(at: string): Promise<string>;
export declare function readTextFileLines(at: string): Promise<string[]>;
/**
 * Convenience: wrapper around fs.readFileSync with text file options
 * - you should only select this if you have no option to go async
 * @param at
 */
export declare function readTextFileSync(at: string): string;
export declare function readFileSync(at: string, opts?: ReadFileOptions | null): Buffer;
export declare function readTextFileLinesSync(at: string): string[];
/**
 * Writes the file at the given location with the provided contents
 * - will create any required supporting folders
 * @param at
 * @param contents
 * @param options
 */
export declare function writeFile(at: string, contents: Buffer | string, options?: WriteFileOptions): Promise<void>;
export declare function writeFileSync(at: string, contents: Buffer, options?: WriteFileOptions): void;
export declare function writeTextFileSync(at: string, contents: string | string[], options?: TextWriteFileOptions): void;
export declare type TextWriteFileOptions = WriteFileOptions & {
    eol: string;
};
/**
 * Writes the text file at the given location with the provided contents
 * - will create any required supporting folders
 * @param at
 * @param contents
 * @param options
 */
export declare function writeTextFile(at: string, contents: string | string[], options?: TextWriteFileOptions): Promise<void>;
/**
 * Creates the required folder if it doesn't exist, including any
 * supporting folders. Does not error if the folder already exists.
 * @param at
 */
export declare function mkdir(at: string): Promise<void>;
export declare function mkdirSync(at: string): void;
/**
 * Tests if the given path is a folder
 * @param at
 */
export declare function folderExists(at: string): Promise<boolean>;
/**
 * Tests if the given path is a folder
 * @param at
 */
export declare function folderExistsSync(at: string): boolean;
/**
 * Tests if the given path is a file
 * @param at
 */
export declare function fileExists(at: string): Promise<boolean>;
/**
 * Tests if the given path is a file
 * @param at
 */
export declare function fileExistsSync(at: string): boolean;
/**
 * Tests if the given path exists at all (could be a folder, file, FIFO, whatever)
 * @param at
 */
export declare function exists(at: string): Promise<boolean>;
/**
 * Tests if the given path exists at all (could be a folder, file, FIFO, whatever)
 * @param at
 */
export declare function existsSync(at: string): boolean;
/**
 * Provides a safe, promise-enclosed wrapper around fs.stat
 * - you either get back a stats object or null, never an error
 * @param at
 */
export declare function stat(at: string): Promise<Stats | null>;
/**
 * Provides a safe, synchronous wrapper around fs.statSync
 * - you either get back a stats object or null, never an error
 * @param at
 */
export declare function statSync(at: string): Stats | null;
export declare enum FsEntities {
    files = 1,
    folders = 2,
    all = 3
}
export declare type ErrorHandler = (e: NodeJS.ErrnoException) => Promise<void> | void;
export interface LsOptions {
    /**
     * flag: return results as full absolute paths
     * - set to false or omit to get paths relative
     *   to the starting point of ls
     */
    fullPaths?: boolean;
    recurse?: boolean;
    /**
     * optional entity type filter (defaults to return files and folders)
     */
    entities?: FsEntities;
    /**
     * RegEx to match for inclusion on any part of the full path for
     * each entry that is found whilst traversing the filesystem
     */
    match?: RegExp | RegExp[];
    /**
     * RegEx to match for exclusion on any part of the full path for
     * each entry that is found whilst traversing the filesystem
     */
    exclude?: RegExp | RegExp[];
    /**
     * One or more regular expressions for folders to ignore. Ignored
     * paths will not be traversed during recursive operations.
     */
    doNotTraverse?: RegExp | RegExp[];
    /**
     * optional callback: if this is provided, you may suppress errors
     * whilst reading the filesystem, or re-throw them to stop traversal
     */
    onError?: ErrorHandler;
    /**
     * optional (defaults to false): typically if the target of an ls invocation
     * does not exist, you should get back an empty set of results (you could always
     * check on existence if you want to with folderExists), but if you really want
     * the ENOENT to bubble up, set this to true
     */
    throwOnMissingTarget?: boolean;
    /**
     * optional: when recurse is specified, traverse no deeper than
     * this into the filesystem
     */
    maxDepth?: number;
    /**
     * optional: to speed up recursive searches for single files,
     * bail out of recursion the moment a single match is found
     * for your filters (or the first item that's found, when no
     * filters are provided)
     */
    stopOnFirstMatch?: boolean;
}
export declare function lsSync(at: string, opts?: LsOptions): string[];
export declare function ls(at: string, opts?: LsOptions): Promise<string[]>;
export declare function rm(at: string): Promise<void>;
export declare function rmSync(at: string): void;
export declare function rmdirSync(at: string): void;
export declare function rename(at: string, to: string, force?: boolean): Promise<void>;
export declare function copyFile(src: string, target: string, options?: CopyFileOptions): Promise<void>;
export declare function findHomeFolder(): string;
export declare function resolveHomePath(relative: string): string;
export declare function chmod(at: string, mode: string | number): Promise<void>;
export declare function chmodSync(at: string, mode: string | number): void;
export declare enum CopyFileOptions {
    errorOnExisting = 0,
    overwriteExisting = 1
}
export declare function rmdir(at: string): Promise<void>;
export {};
