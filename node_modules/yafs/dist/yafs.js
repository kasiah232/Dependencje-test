"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rmdir = exports.CopyFileOptions = exports.chmodSync = exports.chmod = exports.resolveHomePath = exports.findHomeFolder = exports.copyFile = exports.rename = exports.rmdirSync = exports.rmSync = exports.rm = exports.ls = exports.lsSync = exports.FsEntities = exports.statSync = exports.stat = exports.existsSync = exports.exists = exports.fileExistsSync = exports.fileExists = exports.folderExistsSync = exports.folderExists = exports.mkdirSync = exports.mkdir = exports.writeTextFile = exports.writeTextFileSync = exports.writeFileSync = exports.writeFile = exports.readTextFileLinesSync = exports.readFileSync = exports.readTextFileSync = exports.readTextFileLines = exports.readTextFile = exports.readFile = void 0;
const fs = __importStar(require("./fs"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const textOptions = { encoding: "utf8" };
/**
 * Reads the file at the provided location
 * @param at
 * @param opts
 */
function readFile(at, opts) {
    return new Promise((resolve, reject) => {
        if (opts) {
            fs.readFile(at, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
            });
        }
        else {
            fs.readFile(at, (err, data) => {
                return err ? reject(err) : resolve(data);
            });
        }
    });
}
exports.readFile = readFile;
/**
 *
 * Reads the text file at the given location with the provided contents
 * - will create any required supporting folders
 * @param at
 */
function readTextFile(at) {
    return new Promise((resolve, reject) => {
        fs.readFile(at, textOptions, (err, data) => {
            return err
                ? reject(err)
                : resolve(data);
        });
    });
}
exports.readTextFile = readTextFile;
async function readTextFileLines(at) {
    return splitIntoLines(await readTextFile(at));
}
exports.readTextFileLines = readTextFileLines;
/**
 * Convenience: wrapper around fs.readFileSync with text file options
 * - you should only select this if you have no option to go async
 * @param at
 */
function readTextFileSync(at) {
    return readFileSync(at, textOptions).toString();
}
exports.readTextFileSync = readTextFileSync;
function readFileSync(at, opts) {
    return fs.readFileSync(at, opts /* looks like something is up with typings, gonna force it */);
}
exports.readFileSync = readFileSync;
function readTextFileLinesSync(at) {
    return splitIntoLines(readTextFileSync(at));
}
exports.readTextFileLinesSync = readTextFileLinesSync;
function splitIntoLines(str) {
    return str.indexOf("\r\n") > -1
        ? str.split(/\r\n/)
        : str.split(/\n/);
}
/**
 * Writes the file at the given location with the provided contents
 * - will create any required supporting folders
 * @param at
 * @param contents
 * @param options
 */
async function writeFile(at, contents, options) {
    await mkdir(path.dirname(at));
    return new Promise((resolve, reject) => {
        // all of options is supposed to be optional, but the typings demand
        // a concrete options -- future proof by taking different routes
        if (options) {
            fs.writeFile(at, contents, options, err => {
                return err ? reject(err) : resolve();
            });
        }
        else {
            fs.writeFile(at, contents, err => {
                return err ? reject(err) : resolve();
            });
        }
    });
}
exports.writeFile = writeFile;
function writeFileSync(at, contents, options) {
    mkdirSync(path.dirname(at));
    if (options) {
        fs.writeFileSync(at, contents, options);
    }
    else {
        fs.writeFileSync(at, contents);
    }
}
exports.writeFileSync = writeFileSync;
function writeTextFileSync(at, contents, options) {
    if (Array.isArray(contents)) {
        contents = contents.join((options === null || options === void 0 ? void 0 : options.eol) || "\n");
    }
    writeFileSync(at, Buffer.from(contents), options);
}
exports.writeTextFileSync = writeTextFileSync;
/**
 * Writes the text file at the given location with the provided contents
 * - will create any required supporting folders
 * @param at
 * @param contents
 * @param options
 */
function writeTextFile(at, contents, options) {
    if (Array.isArray(contents)) {
        contents = contents.join((options === null || options === void 0 ? void 0 : options.eol) || "\n");
    }
    return writeFile(at, Buffer.from(contents), options);
}
exports.writeTextFile = writeTextFile;
/**
 * Creates the required folder if it doesn't exist, including any
 * supporting folders. Does not error if the folder already exists.
 * @param at
 */
async function mkdir(at) {
    const parts = at.split(/[\\|\/]/);
    if (os.platform() !== "win32" && parts.length > 1) {
        if (parts[0] === "") {
            // we were given an absolute path, starting at /
            // -> need to remove the leading empty part &
            //    prepend / onto the new leading part
            parts.splice(0, 1);
            parts[0] = `/${parts[0]}`;
        }
    }
    for (let i = 0; i < parts.length; i++) {
        const current = path.join(...parts.slice(0, i + 1));
        if (await folderExists(current)) {
            continue;
        }
        await mkdirWithFs(current);
    }
}
exports.mkdir = mkdir;
function mkdirWithFs(at) {
    return new Promise((resolve, reject) => {
        fs.mkdir(at, err => err ? reject(err) : resolve());
    });
}
function mkdirSync(at) {
    const parts = at.split(/[\\|\/]/);
    if (os.platform() !== "win32" && parts.length > 1) {
        if (parts[0] === "") {
            // we were given an absolute path, starting at /
            // -> need to remove the leading empty part &
            //    prepend / onto the new leading part
            parts.splice(0, 1);
            parts[0] = `/${parts[0]}`;
        }
    }
    for (let i = 0; i < parts.length; i++) {
        const current = path.join(...parts.slice(0, i + 1));
        if (folderExistsSync(current)) {
            continue;
        }
        fs.mkdirSync(current);
    }
}
exports.mkdirSync = mkdirSync;
/**
 * Tests if the given path is a folder
 * @param at
 */
async function folderExists(at) {
    const st = await stat(at);
    return !!st && st.isDirectory();
}
exports.folderExists = folderExists;
/**
 * Tests if the given path is a folder
 * @param at
 */
function folderExistsSync(at) {
    try {
        const st = statSync(at);
        return !!st && st.isDirectory();
    }
    catch (e) {
        return false;
    }
}
exports.folderExistsSync = folderExistsSync;
/**
 * Tests if the given path is a file
 * @param at
 */
async function fileExists(at) {
    const st = await stat(at);
    return !!st && st.isFile();
}
exports.fileExists = fileExists;
/**
 * Tests if the given path is a file
 * @param at
 */
function fileExistsSync(at) {
    try {
        const st = statSync(at);
        return !!st && st.isFile();
    }
    catch (e) {
        return false;
    }
}
exports.fileExistsSync = fileExistsSync;
/**
 * Tests if the given path exists at all (could be a folder, file, FIFO, whatever)
 * @param at
 */
async function exists(at) {
    const st = await stat(at);
    return !!st;
}
exports.exists = exists;
/**
 * Tests if the given path exists at all (could be a folder, file, FIFO, whatever)
 * @param at
 */
function existsSync(at) {
    try {
        return !!fs.statSync(at);
    }
    catch (e) {
        return false;
    }
}
exports.existsSync = existsSync;
/**
 * Provides a safe, promise-enclosed wrapper around fs.stat
 * - you either get back a stats object or null, never an error
 * @param at
 */
function stat(at) {
    return new Promise((resolve) => {
        try {
            fs.stat(at, (err, st) => {
                resolve(err
                    ? null
                    : st);
            });
        }
        catch (e) {
            resolve(null);
        }
    });
}
exports.stat = stat;
/**
 * Provides a safe, synchronous wrapper around fs.statSync
 * - you either get back a stats object or null, never an error
 * @param at
 */
function statSync(at) {
    try {
        return fs.statSync(at);
    }
    catch (e) {
        return null;
    }
}
exports.statSync = statSync;
var FsEntities;
(function (FsEntities) {
    FsEntities[FsEntities["files"] = 1] = "files";
    FsEntities[FsEntities["folders"] = 2] = "folders";
    FsEntities[FsEntities["all"] = 3] = "all";
})(FsEntities = exports.FsEntities || (exports.FsEntities = {}));
function resolveMatches(opts) {
    return resolveRegExpArray(opts.match);
}
function resolveExcludes(opts) {
    return resolveRegExpArray(opts.exclude);
}
function resolveRegExpArray(value) {
    if (!value) {
        return [];
    }
    return Array.isArray(value)
        ? value
        : [value];
}
function makeSafeArray(items) {
    if (items === undefined) {
        return [];
    }
    return Array.isArray(items)
        ? items
        : [items];
}
const defaultLsOptions = {
    entities: FsEntities.all,
    throwOnMissingTarget: false
};
function lsSync(at, opts) {
    const options = { ...defaultLsOptions, ...opts };
    const ignoreMissing = !options.throwOnMissingTarget;
    if (ignoreMissing) {
        const atExists = existsSync(at);
        if (!atExists) {
            return [];
        }
    }
    const { entities } = options;
    at = path.resolve(at);
    const matches = resolveMatches(options);
    const excludes = resolveExcludes(options);
    options.doNotTraverse = makeSafeArray(options.doNotTraverse);
    const tester = (fullPath) => {
        let accepted = true;
        if (entities !== FsEntities.all) {
            const isMatch = entities === FsEntities.files
                ? fileExistsSync : folderExistsSync;
            accepted = accepted && isMatch(fullPath);
        }
        const relativePath = path.relative(at, fullPath);
        let matched = !matches.length;
        for (const m of matches) {
            matched = matched || !!relativePath.match(m);
        }
        for (const e of excludes) {
            matched = matched && !relativePath.match(e);
        }
        return accepted && matched;
    };
    const result = lsInternalSync(at, tester, options);
    return (opts === null || opts === void 0 ? void 0 : opts.fullPaths)
        ? result
        : result.map(r => path.relative(at, r));
}
exports.lsSync = lsSync;
async function ls(at, opts) {
    const options = { ...defaultLsOptions, ...opts };
    const ignoreMissing = !options.throwOnMissingTarget;
    if (ignoreMissing) {
        const atExists = await exists(at);
        if (!atExists) {
            // prefer empty results over explosions
            return [];
        }
    }
    const { entities } = options;
    at = path.resolve(at);
    const matches = resolveMatches(options);
    const excludes = resolveExcludes(options);
    options.doNotTraverse = makeSafeArray(options.doNotTraverse);
    const tester = async (fullPath) => {
        let accepted = true;
        if (entities !== FsEntities.all) {
            const isMatch = entities === FsEntities.files
                ? fileExists : folderExists;
            accepted = accepted && await isMatch(fullPath);
        }
        const relativePath = path.relative(at, fullPath);
        let matched = !matches.length;
        for (const m of matches) {
            matched = matched || !!relativePath.match(m);
        }
        for (const e of excludes) {
            matched = matched && !relativePath.match(e);
        }
        return accepted && matched;
    };
    const result = await lsInternal(at, tester, options);
    return (opts === null || opts === void 0 ? void 0 : opts.fullPaths)
        ? result
        : result.map(r => path.relative(at, r));
}
exports.ls = ls;
function lsInternalSync(at, tester, opts, currentDepth) {
    if (currentDepth === undefined) {
        currentDepth = 0;
    }
    currentDepth++;
    const { maxDepth, onError, recurse, stopOnFirstMatch } = opts;
    if (maxDepth !== undefined && currentDepth > maxDepth) {
        return [];
    }
    try {
        const data = fs.readdirSync(at);
        const result = [];
        data.sort();
        const subFolders = [];
        for (const p of data) {
            const fullPath = prependAt(p);
            if (tester(fullPath)) {
                result.push(fullPath);
                if (stopOnFirstMatch) {
                    return result;
                }
            }
            if (!recurse) {
                continue;
            }
            // caller sanitises
            const noTraverse = opts.doNotTraverse;
            let skip = false;
            for (const re of noTraverse) {
                if (fullPath.match(re)) {
                    skip = true;
                    break;
                }
            }
            if (skip) {
                continue;
            }
            // even if tester fails, recurs on demand because test may
            // specifically knock out only stuff in the middle
            if (folderExistsSync(fullPath)) {
                subFolders.push(fullPath);
            }
        }
        for (const sub of subFolders) {
            const subs = lsInternalSync(sub, tester, opts, currentDepth);
            result.push.apply(result, subs);
        }
        result.sort();
        return result;
    }
    catch (e) {
        if (!onError) {
            throw e;
        }
        try {
            onError(e);
            return [];
        }
        catch (e) {
            throw e;
        }
    }
    function prependAt(s) {
        return path.join(at, s);
    }
}
function lsInternal(at, tester, opts, currentDepth) {
    if (currentDepth === undefined) {
        currentDepth = 0;
    }
    currentDepth++;
    const { maxDepth, onError, recurse, stopOnFirstMatch } = opts;
    if (maxDepth !== undefined && currentDepth > maxDepth) {
        return Promise.resolve([]);
    }
    return new Promise(async (resolve, reject) => {
        fs.readdir(at, async (err, data) => {
            if (err) {
                if (!onError) {
                    return reject(err);
                }
                try {
                    await onError(err);
                    return resolve([]);
                }
                catch (e) {
                    return reject(e);
                }
            }
            const result = [];
            data.sort();
            const subFolders = [];
            for (const p of data) {
                const fullPath = prependAt(p);
                if (await tester(fullPath)) {
                    result.push(fullPath);
                    if (stopOnFirstMatch) {
                        return resolve(result);
                    }
                }
                if (!recurse) {
                    continue;
                }
                // caller sanitises
                const noTraverse = opts.doNotTraverse;
                let skip = false;
                for (const re of noTraverse) {
                    if (fullPath.match(re)) {
                        skip = true;
                        break;
                    }
                }
                if (skip) {
                    continue;
                }
                // even if tester fails, recurs on demand because test may
                // specifically knock out only stuff in the middle
                if (await folderExists(fullPath)) {
                    subFolders.push(fullPath);
                }
            }
            for (const sub of subFolders) {
                const subs = await lsInternal(sub, tester, opts, currentDepth);
                result.push.apply(result, subs);
            }
            result.sort();
            resolve(result);
        });
    });
    function prependAt(s) {
        return path.join(at, s);
    }
}
const rmRetries = 50, rmRetryBackoff = 100; // gives up to 5 seconds, with 100ms backoff
async function rm(at) {
    if (await fileExists(at)) {
        return retry(() => unlink(at), rmRetries, rmRetryBackoff);
    }
    if (await folderExists(at)) {
        return deltree(at);
    }
}
exports.rm = rm;
function rmSync(at) {
    if (!fs.rmSync) {
        throw new Error(`fs.rmSync is not supported in this version of node - at least v14 is required`);
    }
    if (folderExistsSync(at)) {
        rmdirSync(at);
        return;
    }
    if (!fileExistsSync(at)) {
        return;
    }
    fs.rmSync(at, { maxRetries: 50 });
}
exports.rmSync = rmSync;
function rmdirSync(at) {
    if (!folderExistsSync(at)) {
        return;
    }
    fs.rmSync(at, {
        maxRetries: 50,
        recursive: true
    });
}
exports.rmdirSync = rmdirSync;
async function deltree(at) {
    const contents = await ls(at, { recurse: true });
    contents.sort().reverse();
    for (const p of contents) {
        const fullPath = path.join(at, p);
        if (await folderExists(fullPath)) {
            await rmdir(fullPath);
        }
        else {
            await rm(fullPath);
        }
    }
    await rmdir(at);
}
async function rename(at, to, force) {
    if (at === to) {
        return;
    }
    if (await exists(to)) {
        if (force) {
            await rm(to);
        }
        else {
            throw new Error(`target '${to}' already exists: specify force: true to overwrite`);
        }
    }
    return retry(() => new Promise((resolve, reject) => {
        fs.rename(at, to, err => {
            if (isENOENT(err)) {
                return reject(new AbortRetriesError(err.message, err));
            }
            return err
                ? reject(err)
                : resolve();
        });
    }), 10, 500);
}
exports.rename = rename;
async function copyFile(src, target, options) {
    options = options !== null && options !== void 0 ? options : CopyFileOptions.errorOnExisting;
    if (!(await fileExists(src))) {
        throw new Error(`file not found at '${src}'`);
    }
    if (await folderExists(target)) {
        const baseName = path.basename(src);
        target = path.join(target, baseName);
    }
    if (options !== CopyFileOptions.overwriteExisting &&
        await fileExists(target)) {
        throw new Error(`target already exists at '${target}'`);
    }
    return new Promise((resolve, reject) => {
        fs.copyFile(src, target, err => {
            return err
                ? reject(err)
                : resolve();
        });
    });
}
exports.copyFile = copyFile;
function findHomeFolder() {
    const environmentVariable = os.platform() === "win32"
        ? "USERPROFILE"
        : "HOME", result = process.env[environmentVariable];
    if (!result) {
        throw new Error(`Unable to determine user home folder (searched environment variable: ${environmentVariable}`);
    }
    return result;
}
exports.findHomeFolder = findHomeFolder;
function resolveHomePath(relative) {
    const home = findHomeFolder();
    return path.join(home, relative);
}
exports.resolveHomePath = resolveHomePath;
async function chmod(at, mode) {
    return new Promise((resolve, reject) => {
        fs.chmod(at, mode, (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}
exports.chmod = chmod;
function chmodSync(at, mode) {
    fs.chmodSync(at, mode);
}
exports.chmodSync = chmodSync;
var CopyFileOptions;
(function (CopyFileOptions) {
    CopyFileOptions[CopyFileOptions["errorOnExisting"] = 0] = "errorOnExisting";
    CopyFileOptions[CopyFileOptions["overwriteExisting"] = 1] = "overwriteExisting";
})(CopyFileOptions = exports.CopyFileOptions || (exports.CopyFileOptions = {}));
class AbortRetriesError extends Error {
    constructor(message, error) {
        super(message);
        this.error = error;
    }
}
async function retry(action, attempts, backoffMs) {
    for (let i = 0; i < attempts; i++) {
        try {
            await action();
            return;
        }
        catch (e) {
            if (e instanceof AbortRetriesError) {
                throw e.error;
            }
            console.error(e);
            if (i === attempts - 1) {
                throw e;
            }
            await sleep(backoffMs);
        }
    }
}
function sleep(ms) {
    return new Promise(resolve => {
        setTimeout(resolve, ms);
    });
}
function unlink(at) {
    return new Promise((resolve, reject) => {
        fs.unlink(at, err => {
            if (isENOENT(err)) {
                resolve();
            }
            return err ? reject(err) : resolve();
        });
    });
}
function rmdir(at) {
    return retry(() => rmdirInternal(at), rmRetries, rmRetryBackoff);
}
exports.rmdir = rmdir;
function isENOENT(err) {
    return !!err && err.code === "ENOENT";
}
function rmdirInternal(at) {
    return new Promise((resolve, reject) => {
        fs.rmdir(at, err => {
            if (isENOENT(err)) {
                resolve();
            }
            return err ? reject(err) : resolve();
        });
    });
}
